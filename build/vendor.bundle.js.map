{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./common/models/coffee-shop.js","webpack:///./node_modules/loopback-boot/index.js","webpack:///./node_modules/loopback-boot/lib sync","webpack:///./node_modules/loopback-boot/lib/bundler.js","webpack:///./node_modules/loopback-boot/lib/compiler.js","webpack:///./node_modules/loopback-boot/lib/config-loader.js","webpack:///./node_modules/loopback-boot/lib/executor.js","webpack:///./node_modules/loopback-boot/lib/require.js","webpack:///./node_modules/loopback-boot/lib/utils.js","webpack:///./server/boot/authentication.js","webpack:///./server/boot/create-sample-models.js","webpack:///./server/boot/root.js","webpack:///./server/boot/routes.js","webpack:///external \"loopback-component-explorer/index.js\"","webpack:///external \"loopback/common/models/access-token.js\"","webpack:///external \"loopback/common/models/acl.js\"","webpack:///external \"loopback/common/models/role-mapping.js\"","webpack:///external \"loopback/common/models/role.js\"","webpack:///external \"loopback/common/models/user.js\"","webpack:///external \"assert\"","webpack:///external \"async\"","webpack:///external \"commondir\"","webpack:///external \"compression\"","webpack:///external \"debug\"","webpack:///external \"errorhandler\"","webpack:///external \"fs\"","webpack:///external \"lodash\"","webpack:///external \"loopback\"","webpack:///external \"loopback-component-explorer\"","webpack:///external \"loopback-connector-mysql\"","webpack:///external \"loopback-datasource-juggler\"","webpack:///external \"module\"","webpack:///external \"path\"","webpack:///external \"semver\"","webpack:///external \"serve-favicon\"","webpack:///external \"source-map-support\"","webpack:///external \"strong-globalize\"","webpack:///external \"toposort\"","webpack:///external \"util\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C,gBAAgB;AAChB;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;;AAEA;AACA,SAAS,mBAAO,CAAC,0CAAkB;AACnC;;AAEA,mBAAmB,mBAAO,CAAC,8EAAqB;AAChD,cAAc,mBAAO,CAAC,oEAAgB;AACtC,cAAc,mBAAO,CAAC,oEAAgB;AACtC,kCAAkC,mBAAO,CAAC,kEAAe;AACzD,YAAY,mBAAO,CAAC,8DAAa;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI,sBAAsB,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,uBAAuB,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,iBAAiB,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc,sBAAsB;AACjD,kCAAkC;AAClC,cAAc,OAAO;AACrB;AACA;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,gBAAgB;AAChB,cAAc,eAAe;AAC7B;AACA,cAAc,OAAO;AACrB,QAAQ,WAAW;AACnB,cAAc,OAAO;AACrB,QAAQ,WAAW;AACnB,cAAc,eAAe;AAC7B;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA,cAAc,eAAe;AAC7B;AACA,cAAc,eAAe;AAC7B;AACA,cAAc,wBAAwB;AACtC;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,cAAc,OAAO;AACrB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sE;;;;;;;;;;;ACpCA;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,gBAAgB,mBAAO,CAAC,4BAAW;AACnC,gBAAgB,mBAAO,CAAC,sBAAQ;AAChC,QAAQ,mBAAO,CAAC,0CAAkB;;AAElC;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB,EAAE;AAC7C,yBAAyB,YAAY,EAAE;;AAEvC;AACA,sBAAsB,oCAAoC,EAAE;;AAE5D;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,iBAAiB;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,UAAU,UAAU,2BAA2B,YAAY;AAC3D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uCAAuC;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,qBAAqB;AAC1D;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,gBAAgB,mBAAO,CAAC,sBAAQ;AAChC,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,eAAe,mBAAO,CAAC,0BAAU;AACjC,mBAAmB,mBAAO,CAAC,0EAAiB;AAC5C,YAAY,mBAAO,CAAC,0DAAS;AAC7B,YAAY,mBAAO,CAAC,oBAAO;AAC3B,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,QAAQ,mBAAO,CAAC,sBAAQ;AACxB,QAAQ,mBAAO,CAAC,0CAAkB;AAClC,4BAA4B,mBAAO,CAAC,8DAAW;;AAE/C;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc,sBAAsB;AACjD,kCAAkC;AAClC;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA,2BAA2B,SAAoB;AAC/C;AACA;AACA,IAAI,QAAkB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,QAAkB;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAe,CAAC,uFAAQ;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAe,CAAC,sFAAO;AACzD;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,uEAAQ,QAAQ,CAAC;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB;AACvB;AACA,GAAG;AACH;;AAEA;AACA;AACA,4BAA4B,gCAAgC,EAAE;AAC9D;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACh1BA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,sBAAQ;AAChC,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,6DAAY;AAChC,YAAY,mBAAO,CAAC,oBAAO;AAC3B,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,QAAQ,mBAAO,CAAC,0CAAkB;;AAElC;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,wDAAwD;AACnE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB,EAAE;AACnD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,wBAAwB,EAAE;;AAElE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA,2BAA2B,uEAAQ,CAAC,CAAC;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,wDAAwD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,KAAK;AACL,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACxTA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,YAAY,mBAAO,CAAC,oBAAO;AAC3B,YAAY,mBAAO,CAAC,oBAAO;AAC3B,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,QAAQ,mBAAO,CAAC,0CAAkB;AAClC,4BAA4B,mBAAO,CAAC,8DAAW;;AAE/C;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,0BAAU;AACrC,GAAG;AACH;AACA;AACA,wBAAwB,eAAe,QAAQ,UAAU;AACzD,iBAAiB,UAAU;AAC3B,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK,kCAAkC,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,UAAU,aAAa,QAAQ;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,UAAU,aAAa,QAAQ,MAAM,QAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,kBAAkB;AAC7D;AACA,WAAW,iBAAiB,aAAa,QAAQ;AACjD;AACA,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD,MAAM,SAAS,KAAK;AAC1E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM,EAAE;AACxC,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gCAAgC,cAAc,OAAO;;AAEhE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,IAAI;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7cA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uEAAQ,UAAU,CAAC;AACnC;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,cAAI;;AAErB;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;;AAEA;AACA,OAAO,oCAAoC;AAC3C,OAAO,mDAAmD;AAC1D,OAAO,2CAA2C;AAClD;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACLA,iE;;;;;;;;;;;ACAA,mE;;;;;;;;;;;ACAA,0D;;;;;;;;;;;ACAA,mE;;;;;;;;;;;ACAA,2D;;;;;;;;;;;ACAA,2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,yC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,wD;;;;;;;;;;;ACAA,qD;;;;;;;;;;;ACAA,wD;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,+C;;;;;;;;;;;ACAA,6C;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,iC","file":"vendor.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","module.exports = function(CoffeeShop) {\n  CoffeeShop.status = function(cb) {\n    var currentDate = new Date();\n    var currentHour = currentDate.getHours();\n    var OPEN_HOUR = 6;\n    var CLOSE_HOUR = 20;\n\n    console.log('Current hour is ' + currentHour);\n\n    var response;\n    if (currentHour > OPEN_HOUR && currentHour < CLOSE_HOUR) {\n      response = 'We are open for business.';\n    } else {\n      response = 'Sorry, we are closed. Open daily from 6am to 8pm.';\n    }\n    cb(null, response);\n  };\n\n  CoffeeShop.remoteMethod(\n    'status',\n    {\n      http: {path: '/status', verb: 'get'},\n      returns: {arg: 'status', type: 'string'}\n    }\n  );\n};\n","// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-boot\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\n// Strong globalize\nvar SG = require('strong-globalize');\nSG.SetRootDir(__dirname);\n\nvar ConfigLoader = require('./lib/config-loader');\nvar compile = require('./lib/compiler');\nvar execute = require('./lib/executor');\nvar addInstructionsToBrowserify = require('./lib/bundler');\nvar utils = require('./lib/utils');\n\n/**\n * Initialize an application from an options object or\n * a set of JSON and JavaScript files.\n *\n * > **NOTE**: This module is primarily intended for use with LoopBack 2.0.\n * It _does_ work with LoopBack 1.x applications, but\n * none of the LoopBack 1.x examples or generated code (scaffolding) use it.\n *\n * This function takes an optional argument that is either a string\n * or an object.\n *\n * If the argument is a string, then it sets the application root directory\n * based on the string value. Then it:\n *\n *  1. Creates DataSources from the `datasources.json` file in the application\n *   root directory.\n *\n *  2. Configures Models from the `model-config.json` file in the application\n *    root directory.\n *\n *  3. Configures the LoopBack Application object from the `config.json` file\n *     in the application root directory. These properties can be accessed\n *     using `app.get('propname')`.\n *\n * If the argument is an object, then it looks for `models`, `dataSources`,\n * 'config', `modelsRootDir`, `dsRootDir`, `appConfigRootDir` and `appRootDir`\n * properties of the object.\n *\n * If the object has no `appRootDir` property then it sets the current working\n * directory as the application root directory.\n *\n * The execution environment, {env}, is established from, in order,\n *  - `options.env`\n *  - `process.env.NODE_ENV`,\n *  - the literal `development`.\n *\n * Then it:\n *\n *  1. Creates DataSources from the `options.dataSources` object, if provided;\n *    otherwise, it searches for the files\n *     - `datasources.json`,\n *     - `datasources.local.js` or `datasources.local.json` (only one),\n *     - `datasources.{env}.js` or `datasources.{env}.json` (only one)\n *\n *    in the directory designated by 'options.dsRootDir', if present, or the\n *    application root directory. It merges the data source definitions from\n *    the files found.\n *\n *  2. Creates Models from the `options.models` object, if provided;\n *    otherwise, it searches for the files\n *     - `model-config.json`,\n *     - `model-config.local.js` or `model-config.local.json` (only one),\n *     - `model-config.{env}.js` or `model-config.{env}.json` (only one)\n *\n *    in the directory designated by 'options.modelsRootDir', if present, or\n *    the application root directory. It merges the model definitions from the\n *    files found.\n *\n *  3. Configures the Application object from the `options.config` object,\n *    if provided;\n *    otherwise, it searches for the files\n *     - `config.json`,\n *     - `config.local.js` or `config.local.json` (only one),\n *     - `config.{env}.js` or `config.{env}.json` (only one)\n *\n *    in the directory designated by 'options.appConfigRootDir', if present, or\n *    the application root directory. It merges the properties from the files\n *    found.\n *\n * In both cases, the function loads JavaScript files in the\n * `/boot` subdirectory of the application root directory with `require()`.\n *\n *  **NOTE:** The version 2.0 of loopback-boot changed the way how models\n *  are created. The `model-config.json` file contains only configuration\n *  options like dataSource and extra relations. To define a model,\n *  create a per-model JSON file in `models/` directory.\n *\n *  **NOTE:** Mixing `bootLoopBackApp(app, bootConfig)` and\n *  `app.model(name, modelConfig)` in multiple\n *  files may result in models being undefined due to race conditions.\n *  To avoid this when using `bootLoopBackApp()` make sure all models are passed\n *  as part of the `models` definition.\n *\n * Throws an error if the config object is not valid or if boot fails.\n *\n * @param app LoopBack application created by `loopback()`.\n * @options {String|Object} options Boot options; If String, this is\n * the application root directory; if object, has below properties.\n * @property {String} [appRootDir] Directory to use when loading JSON and\n * JavaScript files.\n * Defaults to the current directory (`process.cwd()`).\n * @property {String} [appConfigRootDir] Directory to use when loading\n * `config.json`. Defaults to `appRootDir`.\n * @property {Object} [models] Object containing `Model` configurations.\n * @property {Array} [modelDefinitions] List of model definitions to use.\n *   When `options.modelDefinitions` is provided, loopback-boot does not\n *   search filesystem and use only the models provided in this argument.\n * @property {Object} [dataSources] Object containing `DataSource` definitions.\n * @property {String} [modelsRootDir] Directory to use when loading\n * `model-config.json`. Defaults to `appRootDir`.\n * @property {String} [dsRootDir] Directory to use when loading\n * `datasources.json`. Defaults to `appRootDir`.\n * @property {String} [middlewareRootDir] Directory to use when loading\n * `middleware.json`. Defaults to `appRootDir`.\n * @property {String} [componentRootDir] Directory to use when loading\n * `component-config.json`. Defaults to `appRootDir`.\n * @property {String} [env] Environment type, defaults to `process.env.NODE_ENV`\n * or `development`. Common values are `development`, `staging` and\n * `production`; however the applications are free to use any names.\n * @property {Array.<String>} [modelSources] List of directories where to look\n * for files containing model definitions.\n * @property {Object} [middleware] Middleware configuration to use instead\n * of `{appRootDir}/middleware.json`\n * @property {Object} [components] Component configuration to use instead\n * of `{appRootDir}/component-config.json`\n * @property {Array.<String>} [mixinDirs] List of directories where to look\n * for files containing model mixin definitions. All files (mixins) found\n * in these directory are loaded.\n * @property {Array.<String>} [mixinSources] List of directories where to look\n * for files containing model mixin definitions. Only mixins used by\n * application models are loaded from these directories.\n * @property {Array.<String>} [bootDirs] List of directories where to look\n * for boot scripts.\n * @property {Array.<String>} [bootScripts] List of script files to execute\n * on boot.\n * @property {String|Function|Boolean} [normalization] Mixin normalization\n * format: false, 'none', 'classify', 'dasherize' - defaults to 'classify'.\n * @end\n * @param {Function} [callback] Callback function.\n *\n * @header boot(app, [options], [callback])\n */\n\nexports = module.exports = function bootLoopBackApp(app, options, callback) {\n  // backwards compatibility with loopback's app.boot\n  options.env = options.env || app.get('env');\n\n  var instructions = compile(options);\n  execute(app, instructions, callback);\n};\n\n/**\n * Compile boot instructions and add them to a browserify bundler.\n * @param {Object|String} options as described in `bootLoopBackApp` above.\n * @property {String} [appId] Application identifier used to load the correct\n * boot configuration when building multiple applications using browserify.\n * @end\n * @param {Object} bundler A browserify bundler created by `browserify()`.\n *\n * @header boot.compileToBrowserify(options, bundler)\n */\nexports.compileToBrowserify = function(options, bundler) {\n  addInstructionsToBrowserify(compile(options), bundler);\n};\n\n/* -- undocumented low-level API -- */\n\nexports.ConfigLoader = ConfigLoader;\nexports.compile = compile;\nexports.execute = execute;\nexports.utils = utils;\nexports.addInstructionsToBrowserify = addInstructionsToBrowserify;\n","var map = {\n\t\"./common/models/coffee-shop.js\": \"./common/models/coffee-shop.js\",\n\t\"./node_modules/compression\": \"compression\",\n\t\"./node_modules/errorhandler\": \"errorhandler\",\n\t\"./node_modules/loopback\": \"loopback\",\n\t\"./node_modules/loopback-component-explorer/index.js\": \"/home/wj42/work/training/loopback-webpack-example/node_modules/loopback-component-explorer/index.js\",\n\t\"./node_modules/loopback/common/models/access-token.js\": \"/home/wj42/work/training/loopback-webpack-example/node_modules/loopback/common/models/access-token.js\",\n\t\"./node_modules/loopback/common/models/acl.js\": \"/home/wj42/work/training/loopback-webpack-example/node_modules/loopback/common/models/acl.js\",\n\t\"./node_modules/loopback/common/models/role-mapping.js\": \"/home/wj42/work/training/loopback-webpack-example/node_modules/loopback/common/models/role-mapping.js\",\n\t\"./node_modules/loopback/common/models/role.js\": \"/home/wj42/work/training/loopback-webpack-example/node_modules/loopback/common/models/role.js\",\n\t\"./node_modules/loopback/common/models/user.js\": \"/home/wj42/work/training/loopback-webpack-example/node_modules/loopback/common/models/user.js\",\n\t\"./server/boot/authentication.js\": \"./server/boot/authentication.js\",\n\t\"./server/boot/create-sample-models.js\": \"./server/boot/create-sample-models.js\",\n\t\"./server/boot/root.js\": \"./server/boot/root.js\",\n\t\"./server/boot/routes.js\": \"./server/boot/routes.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/loopback-boot/lib sync recursive\";","// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-boot\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar fs = require('fs');\nvar path = require('path');\nvar commondir = require('commondir');\nvar cloneDeep = require('lodash').cloneDeep;\nvar g = require('strong-globalize')();\n\n/**\n * Add boot instructions to a browserify bundler.\n * @param {Object} instructions Boot instructions.\n * @param {Object} bundler A browserify object created by `browserify()`.\n */\n\nmodule.exports = function addInstructionsToBrowserify(instructions, bundler) {\n  bundleModelScripts(instructions, bundler);\n  bundleMixinScripts(instructions, bundler);\n  bundleComponentScripts(instructions, bundler);\n  bundleOtherScripts(instructions, bundler);\n  bundleInstructions(instructions, bundler);\n};\n\nfunction bundleOtherScripts(instructions, bundler) {\n  for (var key in instructions.files) {\n    addScriptsToBundle(key, instructions.files[key], bundler);\n  }\n}\n\nfunction bundleModelScripts(instructions, bundler) {\n  bundleSourceFiles(instructions, 'models', bundler);\n}\n\nfunction bundleMixinScripts(instructions, bundler) {\n  bundleSourceFiles(instructions, 'mixins', bundler);\n}\n\nfunction bundleComponentScripts(instructions, bundler) {\n  bundleSourceFiles(instructions, 'components', bundler);\n}\n\nfunction bundleSourceFiles(instructions, type, bundler) {\n  var files = instructions[type]\n    .map(function(m) { return m.sourceFile; })\n    .filter(function(f) { return !!f; });\n\n  var instructionToFileMapping = instructions[type]\n    .map(function(m) { return files.indexOf(m.sourceFile); });\n\n  addScriptsToBundle(type, files, bundler);\n\n  // Update `sourceFile` properties with the new paths\n  instructionToFileMapping.forEach(function(fileIx, sourceIx) {\n    if (fileIx === -1) return;\n    instructions[type][sourceIx].sourceFile = files[fileIx];\n  });\n}\n\nfunction addScriptsToBundle(name, list, bundler) {\n  if (!list.length) return;\n\n  var root = commondir(list.map(path.dirname));\n\n  for (var ix in list) {\n    var filepath = list[ix];\n\n    // Build a short unique id that does not expose too much\n    // information about the file system, but still preserves\n    // useful information about where is the file coming from.\n    var fileid = 'loopback-boot#' + name + '#' + path.relative(root, filepath);\n\n    // Add the file to the bundle.\n    bundler.require(filepath, { expose: fileid });\n\n    // Rewrite the instructions entry with the new id that will be\n    // used to load the file via `require(fileid)`.\n    list[ix] = fileid;\n  }\n}\n\nfunction bundleInstructions(instructions, bundler) {\n  instructions = cloneDeep(instructions);\n\n  var hasMiddleware = instructions.middleware.phases.length ||\n    instructions.middleware.middleware.length;\n  if (hasMiddleware) {\n    g.warn(\n      'Discarding {{middleware}} instructions,' +\n      ' {{loopback}} client does not support {{middleware}}.');\n  }\n  delete instructions.middleware;\n\n  var instructionsString = JSON.stringify(instructions, null, 2);\n\n  /* The following code does not work due to a bug in browserify\n   * https://github.com/substack/node-browserify/issues/771\n   var instructionsStream = require('resumer')()\n     .queue(instructionsString);\n   instructionsStream.path = 'boot-instructions';\n   b.require(instructionsStream, { expose: 'loopback-boot#instructions' });\n   */\n\n  var instructionId = 'instructions';\n  // Create an unique instruction identifier using the application ID.\n  // This is only useful when multiple loopback applications are being bundled\n  // together.\n  if (instructions.appId)\n    instructionId += '-' + instructions.appId;\n\n  // Write the instructions to a file in our node_modules folder.\n  // The location should not really matter as long as it is .gitignore-ed\n  var instructionsFile = path.resolve(__dirname,\n    '..', 'generated-' + instructionId + '.json');\n  fs.writeFileSync(instructionsFile, instructionsString, 'utf-8');\n\n  var moduleName = 'loopback-boot#' + instructionId;\n  bundler.require(instructionsFile, { expose: moduleName });\n}\n","// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-boot\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar assert = require('assert');\nvar cloneDeep = require('lodash').cloneDeep;\nvar fs = require('fs');\nvar path = require('path');\nvar toposort = require('toposort');\nvar ConfigLoader = require('./config-loader');\nvar utils = require('./utils');\nvar debug = require('debug')('loopback:boot:compiler');\nvar Module = require('module');\nvar _ = require('lodash');\nvar g = require('strong-globalize')();\nvar requireNodeOrEsModule = require('./require');\n\nvar FILE_EXTENSION_JSON = '.json';\n\nfunction arrayToObject(array) {\n  return array.reduce(function(obj, val) {\n    obj[val] = val;\n    return obj;\n  }, {});\n}\n\n/**\n * Gather all bootstrap-related configuration data and compile it into\n * a single object containing instruction for `boot.execute`.\n *\n * @options {String|Object} options Boot options; If String, this is\n * the application root directory; if object, has the properties\n * described in `bootLoopBackApp` options above.\n * @return {Object}\n *\n * @header boot.compile(options)\n */\n\nmodule.exports = function compile(options) {\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = { appRootDir: options };\n  }\n\n  // For setting properties without modifying the original object\n  options = Object.create(options);\n\n  var appRootDir = options.appRootDir = options.appRootDir || process.cwd();\n  var env = options.env || process.env.NODE_ENV || 'development';\n  var scriptExtensions = options.scriptExtensions ?\n    arrayToObject(options.scriptExtensions) :\n    require.extensions;\n\n  var appConfigRootDir = options.appConfigRootDir || appRootDir;\n  var appConfig = options.config ||\n    ConfigLoader.loadAppConfig(appConfigRootDir, env);\n  assertIsValidConfig('app', appConfig);\n\n  var modelsRootDir = options.modelsRootDir || appRootDir;\n  var modelsConfig = options.models ||\n    ConfigLoader.loadModels(modelsRootDir, env);\n  assertIsValidModelConfig(modelsConfig);\n\n  var dsRootDir = options.dsRootDir || appRootDir;\n  var dataSourcesConfig = options.dataSources ||\n    ConfigLoader.loadDataSources(dsRootDir, env);\n  assertIsValidConfig('data source', dataSourcesConfig);\n\n  var middlewareRootDir = options.middlewareRootDir || appRootDir;\n\n  var middlewareConfig = options.middleware ||\n    ConfigLoader.loadMiddleware(middlewareRootDir, env);\n  var middlewareInstructions =\n    buildMiddlewareInstructions(middlewareRootDir, middlewareConfig);\n\n  var componentRootDir = options.componentRootDir || appRootDir;\n  var componentConfig = options.components ||\n      ConfigLoader.loadComponents(componentRootDir, env);\n  var componentInstructions =\n    buildComponentInstructions(componentRootDir, componentConfig);\n\n  // require directories\n  var bootDirs = options.bootDirs || []; // precedence\n  bootDirs = bootDirs.concat(path.join(appRootDir, 'boot'));\n  resolveRelativePaths(bootDirs, appRootDir);\n\n  var bootScripts = options.bootScripts || [];\n  resolveRelativePaths(bootScripts, appRootDir);\n\n  bootDirs.forEach(function(dir) {\n    bootScripts = bootScripts.concat(findScripts(dir, scriptExtensions));\n    var envdir = dir + '/' + env;\n    bootScripts = bootScripts.concat(findScripts(envdir, scriptExtensions));\n  });\n\n  // de-dedup boot scripts -ERS\n  // https://github.com/strongloop/loopback-boot/issues/64\n  bootScripts = _.uniq(bootScripts);\n\n  var modelsMeta = modelsConfig._meta || {};\n  delete modelsConfig._meta;\n\n  var modelSources = options.modelSources || modelsMeta.sources || ['./models'];\n  var modelInstructions = buildAllModelInstructions(\n    modelsRootDir, modelsConfig, modelSources, options.modelDefinitions,\n    scriptExtensions);\n\n  var mixinSources = options.mixinSources || modelsMeta.mixins || ['./mixins'];\n  var mixinInstructions = buildAllMixinInstructions(\n    appRootDir, options, mixinSources, scriptExtensions, modelInstructions);\n\n  // When executor passes the instruction to loopback methods,\n  // loopback modifies the data. Since we are loading the data using `require`,\n  // such change affects also code that calls `require` for the same file.\n  var instructions = {\n    env: env,\n    config: appConfig,\n    dataSources: dataSourcesConfig,\n    models: modelInstructions,\n    middleware: middlewareInstructions,\n    components: componentInstructions,\n    mixins: mixinInstructions,\n    files: {\n      boot: bootScripts,\n    },\n  };\n\n  if (options.appId)\n    instructions.appId = options.appId;\n\n  return cloneDeep(instructions);\n};\n\nfunction assertIsValidConfig(name, config) {\n  if (config) {\n    assert(typeof config === 'object',\n      g.f('%s config must be a valid JSON object', name));\n  }\n}\n\nfunction assertIsValidModelConfig(config) {\n  assertIsValidConfig('model', config);\n  for (var name in config) {\n    var entry = config[name];\n    var options = entry.options || {};\n    var unsupported = entry.properties ||\n      entry.base || options.base ||\n      entry.plural || options.plural;\n\n    if (unsupported) {\n      throw new Error(\n        g.f('The data in {{model-config.json}}' +\n          ' is in the unsupported 1.x format.'));\n    }\n  }\n}\n\n/**\n * Find all javascript files (except for those prefixed with _)\n * and all directories.\n * @param {String} dir Full path of the directory to enumerate.\n * @return {Array.<String>} A list of absolute paths to pass to `require()`.\n * @private\n */\n\nfunction findScripts(dir, scriptExtensions) {\n  assert(dir, g.f('cannot require directory contents without directory name'));\n\n  var files = tryReadDir(dir);\n  scriptExtensions = scriptExtensions || require.extensions;\n\n  // sort files in lowercase alpha for linux\n  files.sort(function(a, b) {\n    a = a.toLowerCase();\n    b = b.toLowerCase();\n\n    if (a < b) {\n      return -1;\n    } else if (b < a) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n\n  var results = [];\n  files.forEach(function(filename) {\n    // ignore index.js and files prefixed with underscore\n    if (filename === 'index.js' || filename[0] === '_') {\n      return;\n    }\n\n    var filepath = path.resolve(path.join(dir, filename));\n    var stats = fs.statSync(filepath);\n\n    // only require files supported by specified extensions\n    if (stats.isFile()) {\n      if (scriptExtensions && isPreferredExtension(filename, scriptExtensions))\n        results.push(filepath);\n      else\n        debug('Skipping file %s - unknown extension', filepath);\n    } else {\n      debug('Skipping directory %s', filepath);\n    }\n  });\n\n  return results;\n}\n\nfunction tryReadDir() {\n  try {\n    return fs.readdirSync.apply(fs, arguments);\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction buildAllModelInstructions(rootDir, modelsConfig, sources,\n                                   modelDefinitions, scriptExtensions) {\n  var registry = verifyModelDefinitions(rootDir, modelDefinitions,\n                                        scriptExtensions);\n  if (!registry) {\n    registry = findModelDefinitions(rootDir, sources, scriptExtensions);\n  }\n\n  var modelNamesToBuild = addAllBaseModels(registry, Object.keys(modelsConfig));\n\n  var instructions = modelNamesToBuild\n    .map(function createModelInstructions(name) {\n      var config = modelsConfig[name];\n      var definition = registry[name] || {};\n\n      debug('Using model \"%s\"\\nConfiguration: %j\\nDefinition %j',\n        name, config, definition.definition);\n\n      return {\n        name: name,\n        config: config,\n        definition: definition.definition,\n        sourceFile: definition.sourceFile,\n      };\n    });\n\n  return sortByInheritance(instructions);\n}\n\nfunction addAllBaseModels(registry, modelNames) {\n  var result = [];\n  var visited = {};\n\n  while (modelNames.length) {\n    var name = modelNames.shift();\n\n    if (visited[name]) continue;\n    visited[name] = true;\n    result.push(name);\n\n    var definition = registry[name] && registry[name].definition;\n    if (!definition) continue;\n\n    var base = getBaseModelName(definition);\n\n    // ignore built-in models like User\n    if (!registry[base]) continue;\n\n    modelNames.push(base);\n  }\n\n  return result;\n}\n\nfunction getBaseModelName(modelDefinition) {\n  if (!modelDefinition)\n    return undefined;\n\n  return modelDefinition.base ||\n    modelDefinition.options && modelDefinition.options.base;\n}\n\nfunction sortByInheritance(instructions) {\n  // create edges Base name -> Model name\n  var edges = instructions\n    .map(function(inst) {\n      return [getBaseModelName(inst.definition), inst.name];\n    });\n\n  var sortedNames = toposort(edges);\n\n  var instructionsByModelName = {};\n  instructions.forEach(function(inst) {\n    instructionsByModelName[inst.name] = inst;\n  });\n\n  return sortedNames\n    // convert to instructions\n    .map(function(name) {\n      return instructionsByModelName[name];\n    })\n    // remove built-in models\n    .filter(function(inst) {\n      return !!inst;\n    });\n}\n\nfunction verifyModelDefinitions(rootDir, modelDefinitions, scriptExtensions) {\n  if (!modelDefinitions || modelDefinitions.length < 1) {\n    return undefined;\n  }\n\n  var registry = {};\n  modelDefinitions.forEach(function(definition, idx) {\n    if (definition.sourceFile) {\n      var fullPath = path.resolve(rootDir, definition.sourceFile);\n      definition.sourceFile = fixFileExtension(\n        fullPath,\n        tryReadDir(path.dirname(fullPath)),\n        scriptExtensions);\n      if (!definition.sourceFile) {\n        debug('Model source code not found: %s - %s', definition.sourceFile);\n      }\n    }\n\n    debug('Found model \"%s\" - %s %s',\n      definition.definition.name,\n      'from options',\n      definition.sourceFile ?\n        path.relative(rootDir, definition.sourceFile) :\n        '(no source file)');\n\n    var modelName = definition.definition.name;\n    if (!modelName) {\n      debug('Skipping model definition without Model name ' +\n        '(from options.modelDefinitions @ index %s)',\n         idx);\n      return;\n    }\n    registry[modelName] = definition;\n  });\n\n  return registry;\n}\n\nfunction findModelDefinitions(rootDir, sources, scriptExtensions) {\n  var registry = {};\n\n  sources.forEach(function(src) {\n    var srcDir = tryResolveAppPath(rootDir, src, { strict: false });\n    if (!srcDir) {\n      debug('Skipping unknown module source dir %j', src);\n      return;\n    }\n\n    var files = tryReadDir(srcDir);\n\n    files\n      .filter(function(f) {\n        return f[0] !== '_' && path.extname(f) === '.json';\n      })\n      .forEach(function(f) {\n        var fullPath = path.resolve(srcDir, f);\n        var entry = loadModelDefinition(rootDir, fullPath, files,\n                                        scriptExtensions);\n        var modelName = entry.definition.name;\n        if (!modelName) {\n          debug('Skipping model definition without Model name: %s',\n            path.relative(srcDir, fullPath));\n          return;\n        }\n        registry[modelName] = entry;\n      });\n  });\n\n  return registry;\n}\n\nfunction resolveAppPath(rootDir, relativePath, resolveOptions) {\n  var resolvedPath = tryResolveAppPath(rootDir, relativePath, resolveOptions);\n  if (resolvedPath === undefined && !resolveOptions.optional) {\n    var err = new Error(g.f('Cannot resolve path \"%s\"', relativePath));\n    err.code = 'PATH_NOT_FOUND';\n    throw err;\n  }\n  return resolvedPath;\n}\n\nfunction tryResolveAppPath(rootDir, relativePath, resolveOptions) {\n  var fullPath;\n  var start = relativePath.substring(0, 2);\n\n  /* In order to retain backward compatibility, we need to support\n   * two ways how to treat values that are not relative nor absolute\n   * path (e.g. `relativePath = 'foobar'`)\n   *  - `resolveOptions.strict = true` searches in `node_modules` only\n   *  - `resolveOptions.strict = false` attempts to resolve the value\n   *     as a relative path first before searching `node_modules`\n   */\n  resolveOptions = resolveOptions || { strict: true };\n\n  var isModuleRelative = false;\n  // would love to use `path.isAbsolute(relativePath)` from node's core module `path`\n  // but unfortunately that is not available in node v0.10.x\n  // https://nodejs.org/dist/latest-v6.x/docs/api/path.html#path_path_isabsolute_path\n  if (relativePath[0] === '/' || /^[a-zA-Z]:[\\\\]{1,2}/.test(relativePath)) {\n    fullPath = relativePath;\n  } else if (start === './' || start === '..') {\n    fullPath = path.resolve(rootDir, relativePath);\n  } else if (!resolveOptions.strict) {\n    isModuleRelative = true;\n    fullPath = path.resolve(rootDir, relativePath);\n  }\n\n  if (fullPath) {\n    // This check is needed to support paths pointing to a directory\n    if (utils.fileExistsSync(fullPath)) {\n      return fullPath;\n    }\n\n    try {\n      fullPath = require.resolve(fullPath);\n      return fullPath;\n    } catch (err) {\n      if (!isModuleRelative) {\n        debug ('Skipping %s - %s', fullPath, err);\n        return undefined;\n      }\n    }\n  }\n\n  // Handle module-relative path, e.g. `loopback/common/models`\n\n  // Module.globalPaths is a list of globally configured paths like\n  //   [ env.NODE_PATH values, $HOME/.node_modules, etc. ]\n  // Module._nodeModulePaths(rootDir) returns a list of paths like\n  //   [ rootDir/node_modules, rootDir/../node_modules, etc. ]\n  var modulePaths = Module.globalPaths\n    .concat(Module._nodeModulePaths(rootDir));\n\n  fullPath = modulePaths\n    .map(function(candidateDir) {\n      var absPath = path.join(candidateDir, relativePath);\n      try {\n        // NOTE(bajtos) We need to create a proper String object here,\n        // otherwise we can't attach additional properties to it\n        var filePath = new String(require.resolve(absPath));\n        filePath.unresolvedPath = absPath;\n        return filePath;\n      } catch (err) {\n        return absPath;\n      }\n    })\n    .filter(function(candidate) {\n      return utils.fileExistsSync(candidate.toString());\n    })\n    [0];\n\n  if (fullPath) {\n    if (fullPath.unresolvedPath && resolveOptions.fullResolve === false)\n      return fullPath.unresolvedPath;\n    // Convert String object back to plain string primitive\n    return fullPath.toString();\n  }\n\n  debug ('Skipping %s - module not found', fullPath);\n  return undefined;\n}\n\nfunction loadModelDefinition(rootDir, jsonFile, allFiles, scriptExtensions) {\n  var definition = require(jsonFile);\n  var basename = path.basename(jsonFile, path.extname(jsonFile));\n  definition.name = definition.name || _.upperFirst(_.camelCase(basename));\n\n  // find a matching file with a supported extension like `.js` or `.coffee`\n  var sourceFile = fixFileExtension(jsonFile, allFiles, scriptExtensions);\n\n  if (sourceFile === undefined) {\n    debug('Model source code not found: %s', sourceFile);\n  }\n\n  debug('Found model \"%s\" - %s %s', definition.name,\n    path.relative(rootDir, jsonFile),\n    sourceFile ? path.relative(rootDir, sourceFile) : '(no source file)');\n\n  return {\n    definition: definition,\n    sourceFile: sourceFile,\n  };\n}\n\nfunction buildMiddlewareInstructions(rootDir, config) {\n  var phasesNames = Object.keys(config);\n  var middlewareList = [];\n  phasesNames.forEach(function(phase) {\n    var phaseConfig = config[phase];\n    Object.keys(phaseConfig).forEach(function(middleware) {\n      var allConfigs = phaseConfig[middleware];\n      if (!Array.isArray(allConfigs))\n        allConfigs = [allConfigs];\n\n      allConfigs.forEach(function(config) {\n        var resolved = resolveMiddlewarePath(rootDir, middleware, config);\n\n        // resolved.sourceFile will be false-y if an optional middleware\n        // is not resolvable.\n        // if a non-optional middleware is not resolvable, it will throw\n        // at resolveAppPath() and not reach here\n        if (!resolved.sourceFile) {\n          return g.log('{{Middleware}} \"%s\" not found: %s',\n            middleware,\n            resolved.optional\n          );\n        }\n\n        var middlewareConfig = cloneDeep(config);\n        middlewareConfig.phase = phase;\n\n        if (middlewareConfig.params) {\n          middlewareConfig.params = resolveMiddlewareParams(\n            rootDir, middlewareConfig.params);\n        }\n\n        var item = {\n          sourceFile: resolved.sourceFile,\n          config: middlewareConfig,\n        };\n        if (resolved.fragment) {\n          item.fragment = resolved.fragment;\n        }\n        middlewareList.push(item);\n      });\n    });\n  });\n\n  var flattenedPhaseNames = phasesNames\n    .map(function getBaseName(name) {\n      return name.replace(/:[^:]+$/, '');\n    })\n    .filter(function differsFromPreviousItem(value, ix, source) {\n      // Skip duplicate entries. That happens when\n      // `name:before` and `name:after` are both translated to `name`\n      return ix === 0 || value !== source[ix - 1];\n    });\n\n  return {\n    phases: flattenedPhaseNames,\n    middleware: middlewareList,\n  };\n}\n\nfunction resolveMiddlewarePath(rootDir, middleware, config) {\n  var resolved = {\n    optional: !!config.optional,\n  };\n\n  var segments = middleware.split('#');\n  var pathName = segments[0];\n  var fragment = segments[1];\n  var middlewarePath = pathName;\n  var opts = {\n    strict: true,\n    optional: !!config.optional,\n  };\n\n  if (fragment) {\n    resolved.fragment = fragment;\n  }\n\n  if (pathName.indexOf('./') === 0 || pathName.indexOf('../') === 0) {\n    // Relative path\n    pathName = path.resolve(rootDir, pathName);\n  }\n\n  var resolveOpts = _.extend(opts, {\n    // Workaround for strong-agent to allow probes to detect that\n    // strong-express-middleware was loaded: exclude the path to the\n    // module main file from the source file path.\n    // For example, return\n    //   node_modules/strong-express-metrics\n    // instead of\n    //   node_modules/strong-express-metrics/index.js\n    fullResolve: false,\n  });\n  var sourceFile = resolveAppScriptPath(rootDir, middlewarePath, resolveOpts);\n\n  if (!fragment) {\n    resolved.sourceFile = sourceFile;\n    return resolved;\n  }\n\n  // Try to require the module and check if <module>.<fragment> is a valid\n  // function\n  var m = requireNodeOrEsModule(sourceFile);\n  if (typeof m[fragment] === 'function') {\n    resolved.sourceFile = sourceFile;\n    return resolved;\n  }\n\n  /*\n   * module/server/middleware/fragment\n   * module/middleware/fragment\n   */\n  var candidates = [\n    pathName + '/server/middleware/' + fragment,\n    pathName + '/middleware/' + fragment,\n    // TODO: [rfeng] Should we support the following flavors?\n    // pathName + '/lib/' + fragment,\n    // pathName + '/' + fragment\n  ];\n\n  var err = undefined; // see https://github.com/eslint/eslint/issues/5744\n  for (var ix in candidates) {\n    try {\n      resolved.sourceFile = resolveAppScriptPath(rootDir, candidates[ix], opts);\n      delete resolved.fragment;\n      return resolved;\n    } catch (e) {\n      // Report the error for the first candidate when no candidate matches\n      if (!err) err = e;\n    }\n  }\n  throw err;\n}\n\n// Match values starting with `$!./` or `$!../`\nvar MIDDLEWARE_PATH_PARAM_REGEX = /^\\$!(\\.\\/|\\.\\.\\/)/;\n\nfunction resolveMiddlewareParams(rootDir, params) {\n  return _.cloneDeepWith(params, function resolvePathParam(value) {\n    if (typeof value === 'string' && MIDDLEWARE_PATH_PARAM_REGEX.test(value)) {\n      return path.resolve(rootDir, value.slice(2));\n    } else {\n      return undefined; // no change\n    }\n  });\n}\n\nfunction buildComponentInstructions(rootDir, componentConfig) {\n  return Object.keys(componentConfig)\n    .filter(function(name) { return !!componentConfig[name]; })\n    .map(function(name) {\n      return {\n        sourceFile: resolveAppScriptPath(rootDir, name, { strict: true }),\n        config: componentConfig[name],\n      };\n    });\n}\n\nfunction resolveRelativePaths(relativePaths, appRootDir) {\n  var resolveOpts = { strict: false };\n  relativePaths.forEach(function(relativePath, k) {\n    var resolvedPath = tryResolveAppPath(appRootDir, relativePath, resolveOpts);\n    if (resolvedPath !== undefined) {\n      relativePaths[k] = resolvedPath;\n    } else {\n      debug ('skipping boot script %s - unknown file', relativePath);\n    }\n  });\n}\n\nfunction getExcludedExtensions() {\n  return {\n    '.json': '.json',\n    /**\n     * This is a temporary workaround for #246\n     * See discussion here for full description of the underlying issue\n     * https://github.com/strongloop/loopback-boot/pull/245#issuecomment-311052798\n     */\n    '.map': '.map',\n    '.node': 'node',\n  };\n}\n\nfunction isPreferredExtension(filename, includeExtensions) {\n  assert(!!includeExtensions, '\"includeExtensions\" argument is required');\n\n  var ext = path.extname(filename);\n  return (ext in includeExtensions) && !(ext in getExcludedExtensions());\n}\n\nfunction fixFileExtension(filepath, files, scriptExtensions) {\n  var results = [];\n  var otherFile;\n\n  /* Prefer coffee scripts over json */\n  if (scriptExtensions && isPreferredExtension(filepath, scriptExtensions)) {\n    return filepath;\n  }\n\n  var basename = path.basename(filepath, FILE_EXTENSION_JSON);\n  var sourceDir = path.dirname(filepath);\n\n  files.forEach(function(f) {\n    otherFile = path.resolve(sourceDir, f);\n\n    var stats = fs.statSync(otherFile);\n    if (stats.isFile()) {\n      var otherFileExtension = path.extname(f);\n\n      if (!(otherFileExtension in getExcludedExtensions()) &&\n        path.basename(f, otherFileExtension) == basename) {\n        if (!scriptExtensions || otherFileExtension in scriptExtensions) {\n          results.push(otherFile);\n        }\n      }\n    }\n  });\n  return (results.length > 0 ? results[0] : undefined);\n}\n\nfunction resolveAppScriptPath(rootDir, relativePath, resolveOptions) {\n  var resolvedPath = resolveAppPath(rootDir, relativePath, resolveOptions);\n  if (!resolvedPath) {\n    return false;\n  }\n  var sourceDir = path.dirname(resolvedPath);\n  var files = tryReadDir(sourceDir);\n  var fixedFile = fixFileExtension(resolvedPath, files);\n  return (fixedFile === undefined ? resolvedPath : fixedFile);\n}\n\nfunction buildAllMixinInstructions(appRootDir, options, mixinSources,\n                                   scriptExtensions, modelInstructions) {\n  // load mixins from `options.mixins`\n  var sourceFiles = options.mixins || [];\n  var mixinDirs = options.mixinDirs || [];\n  var instructionsFromMixins = loadMixins(sourceFiles, options.normalization);\n\n  // load mixins from `options.mixinDirs`\n  sourceFiles = findMixinDefinitions(appRootDir, mixinDirs, scriptExtensions);\n  if (sourceFiles === undefined) return;\n  var instructionsFromMixinDirs = loadMixins(sourceFiles,\n                                             options.normalization);\n\n  /* If `mixinDirs` and `mixinSources` have any directories in common,\n   * then remove the common directories from `mixinSources` */\n  mixinSources = _.difference(mixinSources, mixinDirs);\n\n  // load mixins from `options.mixinSources`\n  sourceFiles = findMixinDefinitions(appRootDir, mixinSources,\n                                     scriptExtensions);\n  if (sourceFiles === undefined) return;\n  var instructionsFromMixinSources = loadMixins(sourceFiles,\n                                                options.normalization);\n\n  // Fetch unique list of mixin names, used in models\n  var modelMixins = fetchMixinNamesUsedInModelInstructions(modelInstructions);\n  modelMixins = _.uniq(modelMixins);\n\n  // Filter-in only mixins, that are used in models\n  instructionsFromMixinSources = filterMixinInstructionsUsingWhitelist(\n    instructionsFromMixinSources, modelMixins);\n\n  var mixins = _.assign(\n    instructionsFromMixins,\n    instructionsFromMixinDirs,\n    instructionsFromMixinSources);\n\n  return _.values(mixins);\n}\n\nfunction findMixinDefinitions(appRootDir, sourceDirs, scriptExtensions) {\n  var files = [];\n  sourceDirs.forEach(function(dir) {\n    var path = tryResolveAppPath(appRootDir, dir);\n    if (!path) {\n      debug('Skipping unknown module source dir %j', dir);\n      return;\n    }\n    files = files.concat(findScripts(path, scriptExtensions));\n  });\n  return files;\n}\n\nfunction loadMixins(sourceFiles, normalization) {\n  var mixinInstructions = {};\n  sourceFiles.forEach(function(filepath) {\n    var dir = path.dirname(filepath);\n    var ext = path.extname(filepath);\n    var name = path.basename(filepath, ext);\n    var metafile = path.join(dir, name + FILE_EXTENSION_JSON);\n\n    name = normalizeMixinName(name, normalization);\n    var meta = {};\n    meta.name = name;\n    if (utils.fileExistsSync(metafile)) {\n      // May overwrite name, not sourceFile\n      _.extend(meta, requireNodeOrEsModule(metafile));\n    }\n    meta.sourceFile = filepath;\n    mixinInstructions[meta.name] = meta;\n  });\n\n  return mixinInstructions;\n}\n\nfunction fetchMixinNamesUsedInModelInstructions(modelInstructions) {\n  return _.flatten(modelInstructions\n  .map(function(model) {\n    return model.definition && model.definition.mixins ?\n      Object.keys(model.definition.mixins) : [];\n  }));\n}\n\nfunction filterMixinInstructionsUsingWhitelist(instructions, includeMixins) {\n  var instructionKeys = Object.keys(instructions);\n  includeMixins = _.intersection(instructionKeys, includeMixins);\n\n  var filteredInstructions = {};\n  instructionKeys.forEach(function(mixinName) {\n    if (includeMixins.indexOf(mixinName) !== -1) {\n      filteredInstructions[mixinName] = instructions[mixinName];\n    }\n  });\n  return filteredInstructions;\n}\n\nfunction normalizeMixinName(str, normalization) {\n  switch (normalization) {\n    case false:\n    case 'none': return str;\n\n    case undefined:\n    case 'classify':\n      str = String(str).replace(/([A-Z]+)/g, ' $1').trim();\n      str = String(str).replace(/[\\W_]/g, ' ').toLowerCase();\n      str = str.replace(/(?:^|\\s|-)\\S/g, function(c) {\n        return c.toUpperCase();\n      });\n      str = str.replace(/\\s+/g, '');\n      return str;\n\n    case 'dasherize':\n      str = String(str).replace(/([A-Z]+)/g, ' $1').trim();\n      str = String(str).replace(/[\\W_]/g, ' ').toLowerCase();\n      str = str.replace(/\\s+/g, '-');\n      return str;\n\n    default:\n      if (typeof normalization === 'function') {\n        return normalization(str);\n      }\n\n      var err = new Error(g.f('Invalid normalization format - \"%s\"',\n        normalization));\n      err.code = 'INVALID_NORMALIZATION_FORMAT';\n      throw err;\n  }\n}\n","// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-boot\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar cloneDeep = require('lodash').cloneDeep;\nvar path = require('path');\nvar utils = require('./utils.js');\nvar debug = require('debug')('loopback:boot:config-loader');\nvar assert = require('assert');\nvar g = require('strong-globalize')();\n\nvar ConfigLoader = exports;\n\n/**\n * Load application config from `config.json` and friends.\n * @param {String} rootDir Directory where to look for files.\n * @param {String} env Environment, usually `process.env.NODE_ENV`\n * @returns {Object}\n */\nConfigLoader.loadAppConfig = function(rootDir, env) {\n  return loadNamed(rootDir, env, 'config', mergeAppConfig);\n};\n\n/**\n * Load data-sources config from `datasources.json` and friends.\n * @param {String} rootDir Directory where to look for files.\n * @param {String} env Environment, usually `process.env.NODE_ENV`\n * @returns {Object}\n */\nConfigLoader.loadDataSources = function(rootDir, env) {\n  return loadNamed(rootDir, env, 'datasources', mergeDataSourceConfig);\n};\n\n/**\n * Load model config from `model-config.json` and friends.\n * @param {String} rootDir Directory where to look for files.\n * @param {String} env Environment, usually `process.env.NODE_ENV`\n * @returns {Object}\n */\nConfigLoader.loadModels = function(rootDir, env) {\n  return loadNamed(rootDir, env, 'model-config', mergeModelConfig);\n};\n\n/**\n * Load middleware config from `middleware.json` and friends.\n * @param {String} rootDir Directory where to look for files.\n * @param {String} env Environment, usually `process.env.NODE_ENV`\n * @returns {Object}\n */\nConfigLoader.loadMiddleware = function(rootDir, env) {\n  return loadNamed(rootDir, env, 'middleware', mergeMiddlewareConfig);\n};\n\n/**\n * Load component config from `component-config.json` and friends.\n * @param {String} rootDir Directory where to look for files.\n * @param {String} env Environment, usually `process.env.NODE_ENV`\n * @returns {Object}\n */\nConfigLoader.loadComponents = function(rootDir, env) {\n  return loadNamed(rootDir, env, 'component-config', mergeComponentConfig);\n};\n\n/*-- Implementation --*/\n\n/**\n * Load named configuration.\n * @param {String} rootDir Directory where to look for files.\n * @param {String} env Environment, usually `process.env.NODE_ENV`\n * @param {String} name\n * @param {function(target:Object, config:Object, filename:String)} mergeFn\n * @returns {Object}\n */\nfunction loadNamed(rootDir, env, name, mergeFn) {\n  var files = findConfigFiles(rootDir, env, name);\n  if (files.length) {\n    debug('found %s %s files', env, name);\n    files.forEach(function(f) { debug('  %s', f); });\n  }\n  var configs = loadConfigFiles(files);\n  var merged = mergeConfigurations(configs, mergeFn);\n\n  debug('merged %s %s configuration %j', env, name, merged);\n\n  return merged;\n}\n\n/**\n * Search `appRootDir` for all files containing configuration for `name`.\n * @param {String} appRootDir\n * @param {String} env Environment, usually `process.env.NODE_ENV`\n * @param {String} name\n * @returns {Array.<String>} Array of absolute file paths.\n */\nfunction findConfigFiles(appRootDir, env, name) {\n  var master = ifExists(name + '.json');\n  if (!master && (ifExistsWithAnyExt(name + '.local') ||\n    ifExistsWithAnyExt(name + '.' + env))) {\n    g.warn('WARNING: Main {{config}} file \"%s.json\" is missing', name);\n  }\n  if (!master) return [];\n\n  var candidates = [\n    master,\n    ifExistsWithAnyExt(name + '.local'),\n    ifExistsWithAnyExt(name + '.' + env),\n  ];\n\n  return candidates.filter(function(c) { return c !== undefined; });\n\n  function ifExists(fileName) {\n    var filepath = path.resolve(appRootDir, fileName);\n    return utils.fileExistsSync(filepath) ? filepath : undefined;\n  }\n\n  function ifExistsWithAnyExt(fileName) {\n    return ifExists(fileName + '.js') || ifExists(fileName + '.json');\n  }\n}\n\n/**\n * Load configuration files into an array of objects.\n * Attach non-enumerable `_filename` property to each object.\n * @param {Array.<String>} files\n * @returns {Array.<Object>}\n */\nfunction loadConfigFiles(files) {\n  return files.map(function(f) {\n    var config = cloneDeep(require(f));\n    Object.defineProperty(config, '_filename', {\n      enumerable: false,\n      value: f,\n    });\n    debug('loaded config file %s: %j', f, config);\n    return config;\n  });\n}\n\n/**\n * Merge multiple configuration objects into a single one.\n * @param {Array.<Object>} configObjects\n * @param {function(target:Object, config:Object, filename:String)} mergeFn\n */\nfunction mergeConfigurations(configObjects, mergeFn) {\n  var result = configObjects.shift() || {};\n  while (configObjects.length) {\n    var next = configObjects.shift();\n    mergeFn(result, next, next._filename);\n  }\n  return result;\n}\n\nfunction mergeDataSourceConfig(target, config, fileName) {\n  var err = mergeObjects(target, config);\n  if (err) {\n    throw new Error(g.f('Cannot apply %s: %s', fileName, err));\n  }\n}\n\nfunction mergeModelConfig(target, config, fileName) {\n  var err = mergeObjects(target, config);\n  if (err) {\n    throw new Error(g.f('Cannot apply %s: %s', fileName, err));\n  }\n}\n\nfunction mergeAppConfig(target, config, fileName) {\n  var err = mergeObjects(target, config);\n  if (err) {\n    throw new Error(g.f('Cannot apply %s: %s', fileName, err));\n  }\n}\n\nfunction mergeMiddlewareConfig(target, config, fileName) {\n  var err = undefined; // see https://github.com/eslint/eslint/issues/5744\n  for (var phase in config) {\n    if (phase in target) {\n      err = mergePhaseConfig(target[phase], config[phase], phase);\n    } else {\n      err = g.f('The {{phase}} \"%s\" is not defined in the main config.', phase);\n    }\n    if (err)\n      throw new Error(g.f('Cannot apply %s: %s', fileName, err));\n  }\n}\n\nfunction mergeNamedItems(arr1, arr2, key) {\n  assert(Array.isArray(arr1), g.f('invalid array: %s', arr1));\n  assert(Array.isArray(arr2), g.f('invalid array: %s', arr2));\n  key = key || 'name';\n  var result = [].concat(arr1);\n  for (var i = 0, n = arr2.length; i < n; i++) {\n    var item = arr2[i];\n    var found = false;\n    if (item[key]) {\n      for (var j = 0, k = result.length; j < k; j++) {\n        if (result[j][key] === item[key]) {\n          mergeObjects(result[j], item);\n          found = true;\n          break;\n        }\n      }\n    }\n    if (!found) {\n      result.push(item);\n    }\n  }\n  return result;\n}\n\nfunction mergePhaseConfig(target, config, phase) {\n  var err = undefined; // see https://github.com/eslint/eslint/issues/5744\n  for (var mw in config) {\n    if (mw in target) {\n      var targetMiddleware = target[mw];\n      var configMiddleware = config[mw];\n      if (Array.isArray(targetMiddleware) && Array.isArray(configMiddleware)) {\n        // Both are arrays, combine them\n        target[mw] = mergeNamedItems(targetMiddleware, configMiddleware);\n      } else if (Array.isArray(targetMiddleware)) {\n        if (typeof configMiddleware === 'object' &&\n          Object.keys(configMiddleware).length) {\n          // Config side is an non-empty object\n          target[mw] = mergeNamedItems(targetMiddleware, [configMiddleware]);\n        }\n      } else if (Array.isArray(configMiddleware)) {\n        if (typeof targetMiddleware === 'object' &&\n          Object.keys(targetMiddleware).length) {\n          // Target side is an non-empty object\n          target[mw] = mergeNamedItems([targetMiddleware], configMiddleware);\n        } else {\n          // Target side is empty\n          target[mw] = configMiddleware;\n        }\n      } else {\n        err = mergeObjects(targetMiddleware, configMiddleware);\n      }\n    } else {\n      err = g.f('The {{middleware}} \"%s\" in phase \"%s\"' +\n        'is not defined in the main config.', mw, phase);\n    }\n    if (err) return err;\n  }\n}\n\nfunction mergeComponentConfig(target, config, fileName) {\n  var err = mergeObjects(target, config);\n  if (err) {\n    throw new Error(g.f('Cannot apply %s: %s', fileName, err));\n  }\n}\n\nfunction mergeObjects(target, config, keyPrefix) {\n  for (var key in config) {\n    var fullKey = keyPrefix ? keyPrefix + '.' + key : key;\n    var err = mergeSingleItemOrProperty(target, config, key, fullKey);\n    if (err) return err;\n  }\n  return null; // no error\n}\n\nfunction mergeSingleItemOrProperty(target, config, key, fullKey) {\n  var origValue = target[key];\n  var newValue = config[key];\n\n  if (!hasCompatibleType(origValue, newValue)) {\n    return 'Cannot merge values of incompatible types for the option `' +\n      fullKey + '`.';\n  }\n\n  if (Array.isArray(origValue)) {\n    return mergeArrays(origValue, newValue, fullKey);\n  }\n\n  if (newValue !== null && typeof origValue === 'object') {\n    return mergeObjects(origValue, newValue, fullKey);\n  }\n\n  target[key] = newValue;\n  return null; // no error\n}\n\nfunction mergeArrays(target, config, keyPrefix) {\n  if (target.length !== config.length) {\n    return 'Cannot merge array values of different length' +\n      ' for the option `' + keyPrefix + '`.';\n  }\n\n  // Use for(;;) to iterate over undefined items, for(in) would skip them.\n  for (var ix = 0; ix < target.length; ix++) {\n    var fullKey = keyPrefix + '[' + ix + ']';\n    var err = mergeSingleItemOrProperty(target, config, ix, fullKey);\n    if (err) return err;\n  }\n\n  return null; // no error\n}\n\nfunction hasCompatibleType(origValue, newValue) {\n  if (origValue === null || origValue === undefined)\n    return true;\n\n  if (Array.isArray(origValue))\n    return Array.isArray(newValue);\n\n  if (typeof origValue === 'object')\n    return typeof newValue === 'object';\n\n  // Note: typeof Array() is 'object' too,\n  // we don't need to explicitly check array types\n  return typeof newValue !== 'object';\n}\n","// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-boot\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar assert = require('assert');\nvar semver = require('semver');\nvar debug = require('debug')('loopback:boot:executor');\nvar async = require('async');\nvar path = require('path');\nvar format = require('util').format;\nvar g = require('strong-globalize')();\nvar requireNodeOrEsModule = require('./require');\n\n/**\n * Execute bootstrap instructions gathered by `boot.compile`.\n *\n * @param {Object} app The loopback app to boot.\n * @options {Object} instructions Boot instructions.\n * @param {Function} [callback] Callback function.\n *\n * @header boot.execute(instructions)\n */\n\nmodule.exports = function execute(app, instructions, callback) {\n  callback = callback || function() {};\n\n  app.booting = true;\n\n  patchAppLoopback(app);\n  assertLoopBackVersion(app);\n\n  setEnv(app, instructions);\n  setHost(app, instructions);\n  setPort(app, instructions);\n  setApiRoot(app, instructions);\n  applyAppConfig(app, instructions);\n\n  setupDataSources(app, instructions);\n  setupModels(app, instructions);\n  setupMiddleware(app, instructions);\n  setupComponents(app, instructions);\n\n  // Run the boot scripts in series synchronously or asynchronously\n  // Please note async supports both styles\n  async.series([\n    function(done) {\n      runBootScripts(app, instructions, done);\n    },\n    function(done) {\n      enableAnonymousSwagger(app, instructions);\n      done();\n    },\n    // Ensure both the \"booted\" event and the callback are always called\n    // in the next tick of the even loop.\n    // See http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n    process.nextTick,\n  ], function(err) {\n    app.booting = false;\n\n    if (err) return callback(err);\n\n    app.emit('booted');\n\n    callback();\n  });\n};\n\nfunction patchAppLoopback(app) {\n  if (app.loopback) return;\n  // app.loopback was introduced in 1.9.0\n  // patch the app object to make loopback-boot work with older versions too\n  try {\n    app.loopback = require('loopback');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      g.error(\n          'When using {{loopback-boot}} with {{loopback}} <1.9, ' +\n          'the {{loopback}} module must be available ' +\n          'for `{{require(\\'loopback\\')}}`.');\n    }\n    throw err;\n  }\n}\n\nfunction assertLoopBackVersion(app) {\n  var RANGE = '1.x || 2.x || ^3.0.0-alpha';\n\n  var loopback = app.loopback;\n  // remove any pre-release tag from the version string,\n  // because semver has special treatment of pre-release versions,\n  // while loopback-boot treats pre-releases the same way as regular versions\n  var version = (loopback.version || '1.0.0').replace(/-.*$/, '');\n  if (!semver.satisfies(version, RANGE)) {\n    var msg = g.f(\n      'The `{{app}}` is powered by an incompatible {{loopback}} version %s. ' +\n      'Supported versions: %s',\n      loopback.version || '(unknown)',\n      RANGE);\n    throw new Error(msg);\n  }\n}\n\nfunction setEnv(app, instructions) {\n  var env = instructions.env;\n  if (env !== undefined)\n    app.set('env', env);\n}\n\nfunction setHost(app, instructions) {\n  // jscs:disable requireCamelCaseOrUpperCaseIdentifiers\n  var host =\n    process.env.npm_config_host ||\n    process.env.OPENSHIFT_SLS_IP ||\n    process.env.OPENSHIFT_NODEJS_IP ||\n    process.env.HOST ||\n    process.env.VCAP_APP_HOST ||\n    instructions.config.host ||\n    process.env.npm_package_config_host ||\n    app.get('host');\n\n  if (host !== undefined) {\n    assert(typeof host === 'string', g.f('{{app.host}} must be a {{string}}'));\n    app.set('host', host);\n  }\n}\n\nfunction setPort(app, instructions) {\n  // jscs:disable requireCamelCaseOrUpperCaseIdentifiers\n  var port = find([\n    process.env.npm_config_port,\n    process.env.OPENSHIFT_SLS_PORT,\n    process.env.OPENSHIFT_NODEJS_PORT,\n    process.env.PORT,\n    process.env.VCAP_APP_PORT,\n    instructions.config.port,\n    process.env.npm_package_config_port,\n    app.get('port'),\n    3000,\n  ], function(p) {\n    return p != null;\n  });\n\n  if (port !== undefined) {\n    var portType = typeof port;\n    assert(portType === 'string' || portType === 'number',\n      g.f('{{app.port}} must be a {{string}} or {{number}}'));\n    app.set('port', port);\n  }\n}\n\nfunction find(array, predicate) {\n  return array.filter(predicate)[0];\n}\n\nfunction setApiRoot(app, instructions) {\n  var restApiRoot =\n    instructions.config.restApiRoot ||\n    app.get('restApiRoot') ||\n    '/api';\n\n  assert(restApiRoot !== undefined, g.f('{{app.restBasePath}} is required'));\n  assert(typeof restApiRoot === 'string',\n    g.f('{{app.restApiRoot}} must be a {{string}}'));\n  assert(/^\\//.test(restApiRoot),\n    g.f('{{app.restApiRoot}} must start with \"/\"'));\n  app.set('restApiRoot', restApiRoot);\n}\n\nfunction applyAppConfig(app, instructions) {\n  var appConfig = instructions.config;\n  for (var configKey in appConfig) {\n    var cur = app.get(configKey);\n    if (cur === undefined || cur === null) {\n      app.set(configKey, appConfig[configKey]);\n    }\n  }\n}\n\nfunction setupDataSources(app, instructions) {\n  forEachKeyedObject(instructions.dataSources, function(key, obj) {\n    var opts = {\n      useEnvVars: true,\n    };\n    obj = getUpdatedConfigObject(app, obj, opts);\n    var lazyConnect = process.env.LB_LAZYCONNECT_DATASOURCES;\n    if (lazyConnect) {\n      obj.lazyConnect =\n        lazyConnect === 'false' || lazyConnect === '0' ? false : true;\n    }\n    app.dataSource(key, obj);\n  });\n}\n\nfunction setupModels(app, instructions) {\n  defineMixins(app, instructions);\n  defineModels(app, instructions);\n\n  instructions.models.forEach(function(data) {\n    // Skip base models that are not exported to the app\n    if (!data.config) return;\n\n    app.model(data._model, data.config);\n  });\n}\n\nfunction defineMixins(app, instructions) {\n  var modelBuilder = (app.registry || app.loopback).modelBuilder;\n  var BaseClass = app.loopback.Model;\n  var mixins = instructions.mixins || [];\n\n  if (!modelBuilder.mixins || !mixins.length) return;\n\n  mixins.forEach(function(obj) {\n    var mixin = requireNodeOrEsModule(obj.sourceFile);\n\n    if (typeof mixin === 'function' || mixin.prototype instanceof BaseClass) {\n      debug('Defining mixin %s', obj.name);\n      modelBuilder.mixins.define(obj.name, mixin); // TODO (name, mixin, meta)\n    } else {\n      debug('Skipping mixin file %s - `module.exports` is not a function' +\n        ' or Loopback model', obj);\n    }\n  });\n}\n\nfunction defineModels(app, instructions) {\n  var registry = app.registry || app.loopback;\n  instructions.models.forEach(function(data) {\n    var name = data.name;\n    var model;\n\n    if (!data.definition) {\n      model = registry.getModel(name);\n      if (!model) {\n        throw new Error(g.f('Cannot configure unknown model %s', name));\n      }\n      debug('Configuring existing model %s', name);\n    } else if (isBuiltinLoopBackModel(app, data)) {\n      model = registry.getModel(name);\n      assert(model, g.f('Built-in model %s should have been defined', name));\n      debug('Configuring built-in LoopBack model %s', name);\n    } else {\n      debug('Creating new model %s %j', name, data.definition);\n      model = registry.createModel(data.definition);\n      if (data.sourceFile) {\n        debug('Loading customization script %s', data.sourceFile);\n        var code = requireNodeOrEsModule(data.sourceFile);\n        if (typeof code === 'function') {\n          debug('Customizing model %s', name);\n          code(model);\n        } else {\n          debug('Skipping model file %s - `module.exports` is not a function',\n            data.sourceFile);\n        }\n      }\n    }\n\n    data._model = model;\n  });\n}\n\n// Regular expression to match built-in loopback models\nvar LOOPBACK_MODEL_REGEXP = new RegExp(\n  ['', 'node_modules', 'loopback', '[^\\\\/\\\\\\\\]+', 'models', '[^\\\\/\\\\\\\\]+\\\\.js$']\n    .join('\\\\' + path.sep));\n\nfunction isBuiltinLoopBackModel(app, data) {\n  // 1. Built-in models are exposed on the loopback object\n  if (!app.loopback[data.name]) return false;\n\n  // 2. Built-in models have a script file `loopback/{facet}/models/{name}.js`\n  var srcFile = data.sourceFile;\n  return srcFile &&\n    LOOPBACK_MODEL_REGEXP.test(srcFile);\n}\n\nfunction forEachKeyedObject(obj, fn) {\n  if (typeof obj !== 'object') return;\n\n  Object.keys(obj).forEach(function(key) {\n    fn(key, obj[key]);\n  });\n}\n\nfunction runScripts(app, list, callback) {\n  list = list || [];\n  var functions = [];\n  list.forEach(function(filepath) {\n    debug('Requiring script %s', filepath);\n    try {\n      var bootFn = requireNodeOrEsModule(filepath);\n      if (typeof bootFn === 'function') {\n        debug('Exported function detected %s', filepath);\n        functions.push({\n          path: filepath,\n          func: bootFn,\n        });\n      }\n    } catch (err) {\n      g.error('Failed loading boot script: %s\\n%s', filepath, err.stack);\n      throw err;\n    }\n  });\n\n  async.eachSeries(functions, function(f, done) {\n    debug('Running script %s', f.path);\n    var cb = function(err) {\n      debug('Async function %s %s', err ? 'failed' : 'finished', f.path);\n      done(err);\n      // Make sure done() isn't called twice, e.g. if a script returns a\n      // thenable object and also calls the passed callback.\n      cb = function() {};\n    };\n    try {\n      var result = f.func(app, cb);\n      if (result && typeof result.then === 'function') {\n        result.then(function() { cb(); }, cb);\n      } else if (f.func.length < 2) {\n        debug('Sync function finished %s', f.path);\n        done();\n      }\n    } catch (err) {\n      debug('Sync function failed %s', f.path, err);\n      done(err);\n    }\n  }, callback);\n}\n\nfunction setupMiddleware(app, instructions) {\n  if (!instructions.middleware) {\n    // the browserified client does not support middleware\n    return;\n  }\n\n  // Phases can be empty\n  var phases = instructions.middleware.phases || [];\n  assert(Array.isArray(phases),\n    g.f('{{instructions.middleware.phases}} must be an {{array}}'));\n\n  var middleware = instructions.middleware.middleware;\n  assert(Array.isArray(middleware),\n    'instructions.middleware.middleware must be an object');\n\n  debug('Defining middleware phases %j', phases);\n  app.defineMiddlewarePhases(phases);\n\n  middleware.forEach(function(data) {\n    debug('Configuring middleware %j%s', data.sourceFile,\n        data.fragment ? ('#' + data.fragment) : '');\n    var factory = requireNodeOrEsModule(data.sourceFile);\n    if (data.fragment) {\n      factory = factory[data.fragment].bind(factory);\n    }\n    assert(typeof factory === 'function',\n      'Middleware factory must be a function');\n    var opts = {\n      useEnvVars: true,\n    };\n    data.config = getUpdatedConfigObject(app, data.config, opts);\n    app.middlewareFromConfig(factory, data.config);\n  });\n}\n\nfunction getUpdatedConfigObject(app, config, opts) {\n  var DYNAMIC_CONFIG_PARAM = /\\$\\{(\\w+)\\}$/;\n  var useEnvVars = opts && opts.useEnvVars;\n\n  function getConfigVariable(param) {\n    var configVariable = param;\n    var match = configVariable.match(DYNAMIC_CONFIG_PARAM);\n    if (match) {\n      var varName = match[1];\n      if (useEnvVars && process.env[varName] !== undefined) {\n        debug('Dynamic Configuration: Resolved via process.env: %s as %s',\n          process.env[varName], param);\n        configVariable = process.env[varName];\n      } else if (app.get(varName) !== undefined) {\n        debug('Dynamic Configuration: Resolved via app.get(): %s as %s',\n          app.get(varName), param);\n        var appValue = app.get(varName);\n        configVariable = appValue;\n      } else {\n        // previously it returns the original string such as \"${restApiRoot}\"\n        // it will now return `undefined`, for the use case of\n        // dynamic datasources url:`undefined` to fallback to other parameters\n        configVariable = undefined;\n        g.warn('%s does not resolve to a valid value, returned as %s. ' +\n        '\"%s\" must be resolvable in Environment variable or by app.get().',\n          param, configVariable, varName);\n        debug('Dynamic Configuration: Cannot resolve variable for `%s`, ' +\n          'returned as %s', varName, configVariable);\n      }\n    }\n    return configVariable;\n  }\n\n  function interpolateVariables(config) {\n    // config is a string and contains a config variable ('${var}')\n    if (typeof config === 'string')\n      return getConfigVariable(config);\n\n    // anything but an array or object\n    if (typeof config !== 'object' || config == null)\n      return config;\n\n    // recurse into array elements\n    if (Array.isArray(config))\n      return config.map(interpolateVariables);\n\n    // Not a plain object. Examples: RegExp, Date,\n    if (!config.constructor || config.constructor !== Object)\n      return config;\n\n    // recurse into object props\n    var interpolated = {};\n    Object.keys(config).forEach(function(configKey) {\n      var value = config[configKey];\n      if (Array.isArray(value)) {\n        interpolated[configKey] = value.map(interpolateVariables);\n      } else if (typeof value === 'string') {\n        interpolated[configKey] = getConfigVariable(value);\n      } else if (value === null) {\n        interpolated[configKey] = value;\n      } else if (typeof value === 'object' && Object.keys(value).length) {\n        interpolated[configKey] = interpolateVariables(value);\n      } else {\n        interpolated[configKey] = value;\n      }\n    });\n    return interpolated;\n  }\n\n  return interpolateVariables(config);\n}\n\nfunction setupComponents(app, instructions) {\n  instructions.components.forEach(function(data) {\n    debug('Configuring component %j', data.sourceFile);\n    var configFn = requireNodeOrEsModule(data.sourceFile);\n    var opts = {\n      useEnvVars: true,\n    };\n    data.config = getUpdatedConfigObject(app, data.config, opts);\n    configFn(app, data.config);\n  });\n}\n\nfunction runBootScripts(app, instructions, callback) {\n  runScripts(app, instructions.files.boot, callback);\n}\n\nfunction enableAnonymousSwagger(app, instructions) {\n  // disable token requirement for swagger, if available\n  var swagger = app.remotes().exports.swagger;\n  if (!swagger) return;\n\n  var appConfig = instructions.config;\n  var requireTokenForSwagger = appConfig.swagger &&\n    appConfig.swagger.requireToken;\n  swagger.requireToken = requireTokenForSwagger || false;\n}\n","// Copyright IBM Corp. 2015,2017. All Rights Reserved.\n// Node module: loopback-boot\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nmodule.exports = function requireNodeOrEsModule(sourceFile) {\n  var exports = require(sourceFile);\n  return exports && exports.__esModule ? exports.default : exports;\n};\n","// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: loopback-boot\n// This file is licensed under the MIT License.\n// License text available at https://opensource.org/licenses/MIT\n\nvar fs = require('fs');\n\nexports.fileExistsSync = fileExistsSync;\n\n/**\n * Check synchronously if a filepath points to an existing file.\n * Replaces calls to fs.existsSync, which is deprecated (see:\n * https://github.com/nodejs/node/pull/166).\n *\n * @param   {String} filepath The absolute path to check\n * @returns {Boolean}  True if the file exists\n */\nfunction fileExistsSync(filepath) {\n  try {\n    fs.statSync(filepath);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","module.exports = function enableAuthentication(server) {\n  // enable authentication\n  server.enableAuth();\n};\n","module.exports = function(app) {\n  app.dataSources.mysqlDs.automigrate('CoffeeShop', function(err) {\n    if (err) throw err;\n\n    app.models.CoffeeShop.create([\n      {name: 'Bel Cafe', city: 'Vancouver'},\n      {name: 'Three Bees Coffee House', city: 'San Mateo'},\n      {name: 'Caffe Artigiano', city: 'Vancouver'},\n    ], function(err, coffeeShops) {\n      if (err) throw err;\n\n      console.log('Models created: \\n', coffeeShops);\n    });\n  });\n};\n","module.exports = function(server) {\n  // Install a `/` route that returns server status\n  var router = server.loopback.Router();\n  router.get('/', server.loopback.status());\n  server.use(router);\n};\n","module.exports = function(app) {\n  // Install a \"/ping\" route that returns \"pong\"\n  app.get('/ping', function(req, res) {\n    res.send('pong');\n  });\n};\n","module.exports = require(\"loopback-component-explorer/index.js\");","module.exports = require(\"loopback/common/models/access-token.js\");","module.exports = require(\"loopback/common/models/acl.js\");","module.exports = require(\"loopback/common/models/role-mapping.js\");","module.exports = require(\"loopback/common/models/role.js\");","module.exports = require(\"loopback/common/models/user.js\");","module.exports = require(\"assert\");","module.exports = require(\"async\");","module.exports = require(\"commondir\");","module.exports = require(\"compression\");","module.exports = require(\"debug\");","module.exports = require(\"errorhandler\");","module.exports = require(\"fs\");","module.exports = require(\"lodash\");","module.exports = require(\"loopback\");","module.exports = require(\"loopback-component-explorer\");","module.exports = require(\"loopback-connector-mysql\");","module.exports = require(\"loopback-datasource-juggler\");","module.exports = require(\"module\");","module.exports = require(\"path\");","module.exports = require(\"semver\");","module.exports = require(\"serve-favicon\");","module.exports = require(\"source-map-support\");","module.exports = require(\"strong-globalize\");","module.exports = require(\"toposort\");","module.exports = require(\"util\");"],"sourceRoot":""}